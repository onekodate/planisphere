<!doctype html>
<html>
    <head>
        <meta charset=utf-8>
        <title>Planisphere</title>
        <style>
            #map{
                height:100vw;
                width:100vw;
            }
            #map svg{
                width:100%;
                height:100%;
            }
        </style>
    </head>
    <body>
        <button onclick="geolocation()">Your Location</button>
        <input type="datetime-local" min="2021-09-23T00:00" max="2022-10-03T00:00" onChange="time_change(new Date(this.value));">
        <table>
            <tr><th>Location</th><td id=location>Tokyo 35.69,139.69</td></tr>
            <tr><th>Date</th><td id=date>Sep 23 2021 22:09</td></tr>
        </table>
        <div id="map"></div>
        <table id=table></table>
		<input type=file id=file onChange="loadFile();">
        https://ssd.jpl.nasa.gov/planets/approx_pos.html
        http://fnorio.com/0098spherical_trigonometry1/spherical_trigonometry1.html
        https://observablehq.com/@mbostock/solar-path

    </body>
    <a id=download></a>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script>
		const elem=(id)=>document.getElementById(id);
/* Planisphere */
        const theta=(x,y)=>{
            return x>0  ? Math.acos(y/Math.sqrt(x**2+y**2))
                        :y>0? Math.asin(x/Math.sqrt(x**2+y**2))
                            : Math.PI-Math.asin(x/Math.sqrt(x**2+y**2));
        }
        const planisphere=()=>{
    /* Keplerian to Planet Coordinates */
            const c_year=(now.time-now.j2000)/1000/60/60/24/36525;
            const planet_coords=planet.map(val=>{
                const v={a:0,e:0,i:0,l:0,w:0,o:0,m:0,E:0,x:0,y:0};
                ["a","e","i","l","w","o"].forEach(key=>{
                    v[key]=(val[key][1]*c_year+val[key][0]);
                });
                v.m=v.l-v.w;
                v.E=v.m;
                while(true){
                    const del_E=(v.m-(v.E-v.e*Math.sin(v.E)))/(1-v.e*Math.cos(v.E));
                    v.E=v.E+del_E;
                    if(del_E<1e-6) break;
                }
                v.x=v.a*(Math.cos(v.E)-v.e);
                v.y=v.a*Math.sqrt(1-v.e**2)*Math.sin(v.E);
                const cw=Math.cos(v.w-v.o);
                const sw=Math.sin(v.w-v.o);
                const co=Math.cos(v.o);
                const so=Math.sin(v.o);
                const ci=Math.cos(v.i);
                const si=Math.sin(v.i);
                return {
                    name:val.name,
                    coor:[  (cw*co-sw*so*ci)*v.x+(-sw*co-cw*so*ci)*v.y,
                            (cw*so+sw*co*ci)*v.x+(-sw*so+cw*co*ci)*v.y,
                            sw*si*v.x+cw*si*v.y],
                };
            });
            planet_coords.push({
                name:"Sun",
                coor:[0,0,0],
            });
/*
            d3.select("#map").select("svg").remove();
            charts=(()=>{
                const height=600,width=600;
                const margin={
                    top:0,
                    right:0,
                    bottom:0,
                    left:0,
                };
                const zoom=2;
                const x=d3.scaleLinear()
                            .domain([-zoom,zoom])
                            .range([margin.left,width-margin.right]);
                const y=d3.scaleLinear()
                            .domain([-zoom,zoom])
                            .range([height-margin.bottom,margin.top]);
                const xAxis=g=>g
                    .attr("transform","translate(0,"+String(height-margin.bottom)+")")
                    .call(d3.axisBottom(x).ticks(10));
                const yAxis=g=>g
                    .attr("transform","translate("+String(margin.left)+",0)")
                    .call(d3.axisLeft(y).ticks(10));
                const svg=d3.select("#map")
                    .append("svg")
                    .attr("viewBox",[0,0,width,height]);
                svg.append("g")
                    .call(xAxis);
                svg.append("g")
                    .call(yAxis);
                const path=svg.append("g")
                    .selectAll("circle")
                    .data(planet_coords.map(val=>val.coor.slice(0,2)))
                    .enter()
                    .append("circle")
                        .attr("cx",d=>x(d[0]))
                        .attr("cy",d=>y(d[1]))
                        .attr("fill","steelblue")
                        .attr("r",4)
                return svg.node();
            })();
*/
    /* Moon Coordinate */
            const bary_coor=planet_coords.splice(2,1)[0].coor;
            const moon_coor=(()=>{
                const arr=moon.filter(val=>Math.abs(val.date-now.time)/1000/60/60/24<1);
                const v={a:0,e:0,i:0,l:0,w:0,o:0,E:0,x:0,y:0};
                ["a","e","i","E","w","o"].forEach(key=>{
                        v[key]=arr.reduce((acc,cur)=>acc+cur[key]*Math.abs(cur.date-now.time)/1000/60/60/24,0);
                });
                v.x=v.a*(Math.cos(v.E)-v.e);
                v.y=v.a*Math.sqrt(1-v.e**2)*Math.sin(v.E);
                const cw=Math.cos(v.w);
                const sw=Math.sin(v.w);
                const co=Math.cos(v.o);
                const so=Math.sin(v.o);
                const ci=Math.cos(v.i);
                const si=Math.sin(v.i);
                return [  (cw*co-sw*so*ci)*v.x+(-sw*co-cw*so*ci)*v.y,
                            (cw*so+sw*co*ci)*v.x+(-sw*so+cw*co*ci)*v.y,
                            sw*si*v.x+cw*si*v.y];
            })();
            planet_coords.push({
                name:"Moon",
                coor:bary_coor.map((val,idx)=>val+moon_coor[idx]),
            });
    /* Planet Argument */
            const earth_coor=bary_coor.map((val,idx)=>val-0.0123*moon_coor[idx]);
            planet_coords.forEach(val=>{
                const coor=val.coor.map((v,i)=>v-earth_coor[i]);
                const index=star.findIndex(v=>v.name==val.name);
                star[index].phi=Math.asin(coor[2]/Math.sqrt(coor.reduce((acc,cur)=>acc+cur**2,0)));
                star[index].theta=theta(coor[0],coor[1]);
            });
    /* Rotation according to Location */
            // 自転軸の傾き x
            const oblique=(84381.406-46.836768*c_year-0.00059*c_year**2+0.001813*c_year**3)/60/60/180*Math.PI;
            // 自転 z'
            const th_dash=2*Math.PI/86164.098903691*(now.time-new Date("2021-12-22 21:00:00"))/1000+now.coor[0]*Math.PI/180;
            // 場所 x'
            const ph_dash=Math.PI/180*(90-now.coor[1]);
            const stars=star.map(val=>{
                const x0y0z0=[  Math.cos(val.phi)*Math.cos(val.theta),
                                Math.cos(val.phi)*Math.sin(val.theta),
                                Math.sin(val.phi) ];
                const x0y1z1=[  x0y0z0[0],
                                 Math.cos(oblique)*x0y0z0[1]+Math.sin(oblique)*x0y0z0[2],
                                -Math.sin(oblique)*x0y0z0[1]+Math.cos(oblique)*x0y0z0[2] ];
                const x1y2z1=[   Math.cos(th_dash)*x0y1z1[1]+Math.sin(th_dash)*x0y1z1[2],
                                -Math.sin(th_dash)*x0y1z1[1]+Math.cos(th_dash)*x0y1z1[2], 
                                x0y1z1[2] ];
                const x1y3z2=[  x1y2z1[0],
                                 Math.cos(ph_dash)*x1y2z1[1]+Math.sin(ph_dash)*x1y2z1[2],
                                -Math.sin(ph_dash)*x1y2z1[1]+Math.cos(ph_dash)*x1y2z1[2] ];
                return {
                    name:val.name,
                    id:val.id,
                    mag:val.mag,
                    color:val.color,
                    phi:Math.asin(x1y3z2[2]/Math.sqrt(x1y3z2.reduce((acc,cur)=>acc+cur**2,0)))*180/Math.PI,
                    theta:theta(x1y3z2[0],x1y3z2[1])*180/Math.PI,
                };
            }).filter(val=>val.phi>0);
    /* D3.js */
            (()=>{
                const width=600,height=600;
                const cx = width / 2;
                const cy = height / 2;
                const xAxis = g => g                    // 外周軸
                    .call(g => g.append("g")
                        .attr("stroke", "currentColor")
                        .selectAll("line")                  // line
                        .data(d3.range(360))                    // 0-360
                        .join("line")
                        .datum(d => [
                            projection([d, 0]),
                            projection([d, d % 10 ? -1 : -2])   // 外周 tick y方向で定義？
                        ])
                        .attr("x1", ([[x1]]) => x1)
                        .attr("x2", ([, [x2]]) => x2)
                        .attr("y1", ([[, y1]]) => y1)
                        .attr("y2", ([, [, y2]]) => y2))
                    .call(g => g.append("g")
                        .selectAll("text")                  // text
                        .data(d3.range(0, 360, 10))         // 10°刻みで文字を入れる
                        .join("text")
                        .attr("dy", "0.35em")
                        .text(d => d === 0 ? "N" : d === 90 ? "W" : d === 180 ? "S" : d === 270 ? "E" : d+"°") // 文字をどう入れるか
                        .attr("font-size", d => d % 90 ? null : 14)             // Font-Size
                        .attr("font-weight", d => d % 90 ? null : "bold")       // Font-Weight    
                        .datum(d => projection([d, -4]))                        // 位置
                        .attr("x", ([x]) => x)
                        .attr("y", ([, y]) => y))
                const yAxis = g => g
                    .call(g => g.append("g")
                        .selectAll("text")                 // text
                        .data(d3.range(10, 91, 10))        // every 10°
                        .join("text")
                        .attr("dy", "0.35em")
                        .text(d => d+"°")                // テンプレート
                        .datum(d => projection([180, d]))
                        .attr("x", ([x]) => x)
                        .attr("y", ([, y]) => y))
//                const path = d3.geoPath(projection)
                const outline = d3.geoCircle().radius(90).center([0, 90])();    // 外周軸
                const graticule = d3.geoGraticule().stepMinor([15, 10])();      // 放射線
                const svg = d3.create("svg")
                    .attr("viewBox", [0, 0, width, height])
                    .attr("font-family", "sans-serif")
                    .attr("font-size", 10)
                    .attr("text-anchor", "middle")
                    .attr("fill", "currentColor")
                    .style("margin", "0 -14px")
                    .style("display", "block");

                svg.append("path")
                    .attr("d", path(graticule))
                    .attr("fill", "none")
                    .attr("stroke", "currentColor")
                    .attr("stroke-opacity", 0.2);

                svg.append("path")
                    .attr("d", path(outline))
                    .attr("fill", "none")
                    .attr("stroke", "currentColor");

                svg.append("g")
                    .call(xAxis);

                svg.append("g")
                    .call(yAxis);

                const sunPath = svg.append("path")
                    .attr("fill", "none")
                    .attr("stroke", "red")
                    .attr("stroke-width", 2);

                const hour = svg.append("g")
                    .selectAll("g")
                    .data(d3.range(24))
                    .join("g");

                hour.append("circle")
                    .attr("fill", "black")
                    .attr("r", 2);

                hour.append("text")
                    .attr("dy", "-0.4em")
                    .attr("stroke", "white")
                    .attr("stroke-width", 4)
                    .attr("stroke-linejoin", "round")
                    .attr("fill", "none")
                    .clone(true)
                    .attr("stroke", null)
                    .attr("fill", "black");

                function update(date) {
                    const start = d3.utcHour.offset(solar.noon(date), -12);
                    const end = d3.utcHour.offset(start, 24);
                    sunPath.attr("d", path({type: "LineString", coordinates: d3.utcMinutes(start, end).map(solar.position)}));
                    hour.data(d3.utcHours(start, end));
                    hour.attr("transform", d => `translate(${projection(solar.position(d))})`);
                    hour.select("text:first-of-type").text(formatHour);
                    hour.select("text:last-of-type").text(formatHour);
                }
                update = chart.update(date)
                return Object.assign(svg.node(), {update});
                            })();
        };
/* File */
        var result,planet=[],moon=[],stars=[];
		const loadFile=()=>{
            const download=(file,name)=>{
                const downloadLink=elem("download");
                const blob=new Blob([JSON.stringify(file)],{type:"application/json"});
                downloadLink.href=URL.createObjectURL(blob);
                downloadLink.download=name+".json";
                downloadLink.click();
            };
			const reader=new FileReader();
			reader.onload=(event)=>{
                const filename=elem("file").value;
                result=event.target.result;
                if(filename.includes(".txt")){
                    if(filename.includes("p_elem_t1")){
                        planet=result
                            .replace(/\n /g,"  ")
                            .split("\n")
                            .slice(10,16)
                            .map(val=>{
                                val=val
                                    .split(/   */)
                                    .map((v,i)=>{
                                        if(isNaN(Number(v))) return v;
                                        else return Number(v);
                                    });
                                return {
                                    name:val[0],
                                    unit:"century year",
                                    a:[val[1],val[7]],
                                    e:[val[2],val[8]],
                                    i:[val[3]*Math.PI/180,val[9]*Math.PI/180],
                                    l:[val[4]*Math.PI/180,val[10]*Math.PI/180],
                                    w:[val[5]*Math.PI/180,val[11]*Math.PI/180],
                                    o:[val[6]*Math.PI/180,val[12]*Math.PI/180],
                                }
                            });
                        time_change(new Date);
    //                    download(planet,"planet");
                    }else if(filename.includes("moon")){
                        moon=result
                            .replace(/\r\n /g," ")
                            .replace(/..=/g,"")
                            .replace(/2.*D\. /g,"")
                            .replace(/ TDB /g,"")
                            .split("\n").map(val=>{
                                const arr=val.split("  ");
                                return {
                                    date:new Date(arr[0]),
                                    e:Number(arr[1]),
                                    i:Number(arr[3])*Math.PI/180,
                                    o:Number(arr[4])*Math.PI/180,
                                    w:Number(arr[5])*Math.PI/180,
                                    E:Number(arr[9])*Math.PI/180,
                                    a:Number(arr[10]),
                                };
                            });
    //                    download(moon,"moon");
                    }
                }else if(filename.includes(".csv")){
                    if(filename.includes("star")){
                        const phi=(decl)=>{
                            if(decl=="0") return 0;
                            else{
                                const s=(decl[0]=="+"?1:-1);
                                const arr=decl.substr(1,).split(" ").map(val=>Number(val));
                                return (arr[0]*Math.PI/180+arr[1]*Math.PI/180/60+arr[2]*Math.PI/180/60/60)*s;
                            }
                        }
                        const star_th=(asce)=>{
                            if(asce=="0") return 0;
                            else{
                                const arr=asce.split(" ").map(val=>Number(val));
                                return arr[0]*2*Math.PI/24+arr[1]*2*Math.PI/24/60+arr[2]*2*Math.PI/24/60/60;
                            }
                        }
                        const color=(spec)=>{
                            let tcp=
                                ["O","B","A","F","G","K","M"].includes(spec[0])?
                                     spec[0]=="O"?45+(45-29)-(45-29)/5*Number(spec[1])
                                    :spec[0]=="B"?29 -(29-9.6)/10*Number(spec[1])
                                    :spec[0]=="A"?9.6-(9.6-7.2)/10*Number(spec[1])
                                    :spec[0]=="F"?7.2-(7.2-6.0)/10*Number(spec[1])
                                    :spec[0]=="G"?6.0-(6.0-5.3)/10*Number(spec[1])
                                    :spec[0]=="K"?5.3-(5.3-3.9)/10*Number(spec[1])
                                    :spec[0]=="M"?3.9-(3.9-2.4)/10*Number(spec[1])
                                    :6.5
                                :spec=="0"      ?6.5
                                :!isNaN(spec)   ?spec
                                :6.5;
                            tcp= tcp<4 ?4
                                :tcp<25?tcp
                                :25;
                            const x=tcp<7   ?-4.6070/tcp**3+2.9678/tcp**2+0.09911/tcp+0.244063
                                            :-2.0064/tcp**3+1.9018/tcp**2+0.24748/tcp+0.237040;
                            const y=-3.000*x**2+2.870*x-0.275;
                            const z=1-x-y;
                            const rgb=[  3.2406*x-1.5372*y-0.4986*z,
                                        -0.9689*x+1.8758*y+0.0415*z,
                                        0.0557*x-0.2040*y+1.0570*z];
                            return rgb.reduce((acc,val)=>acc+Math.round((1.055*(val/Math.max(...rgb))**(1/2.4)-0.055)*255).toString(16),"#");
                        }
                        star=result.split("\r\n").filter(val=>val.length>0).map(val=>{
                            val=val.split(",");
                            return {
                                name:val[0],
                                mag:Number(val[1]),
                                id:val[2],
                                phi:phi(val[4]),
                                theta:star_th(val[3]),
                                color:color(val[5]),
                            };
                        });
//                        download(star,"star");
                    }
                }else if(filename.includes(".json")){
                    if(filename.includes("planet")) planet=JSON.parse(result);
                    else if(filename.includes("moon")) moon=JSON.parse(result);
                    else if(filename.includes("star")) star=JSON.parse(result);
                }
            };
			reader.readAsText(elem("file").files[0],"utf-8");
		};
        const openFile=()=>{
            Promise.all(["star","moon","planet"].map((val,idx)=>{
                return new Promise((resolve,reject)=>{
                    fetch("./"+val+".json").then((response)=>response.json()).then((jsonData)=>{
                        result[idx]=jsonData;
                        resolve();
                    }).catch(()=>reject())
                });
            })).then(()=>{
                console.log("Success");
                star=result[0];
                moon=result[1];
                planet=result[2];
            }).catch(()=>console.log("Failed"));
        };
        async function apiFetch(date){
            ["10","301","199","299","499","599","699"].map(async (val)=>{
                const url="https://ssd.jpl.nasa.gov/api/horizons.api"
                    +"?format=json"
                    +"&COMMAND='"+val+"'"
                    +"&OBJ_DATA='YES'"
                    +"&MAKE_EPHEM='YES'"
                    +"&EPHEM_TYPE='OBSERVER'"
                    +"&CENTER='500@399'"
                    +"&START_TIME='2021-09-30 18:57'"
                    +"&STOP_TIME='2011-09-30 18:58'"
                    +"&STEP_SIZE='1 m'";
                const res=await fetch(url);
                return (await res.text());
            });
        }
/* Time and Location */
        const now={
            time:0,
            j2000:new Date("2000-01-01 21:00:00"),
            coor:[35+39/60+29.1572/60/60,139+44/60+28.8869/60/60],
        };
        const time_change=(date)=>{
                    now.time=date;
                    elem("date").innerText=String(date).slice(4,21);
        //            planet_location();
                }
        const geolocation=()=>{
            navigator.geolocation.getCurrentPosition((pos)=>{
                now.coor=[pos.coords.latitude,pos.coords.longitude];
                elem("location").innerText=now.coor;
            },(error)=>{
                if(error==1) console.log("Access Denied");
                else console.log("Please Try Again");
            });
        };
/* Start */
//        time_change(new Date);
//        openFile();
	</script>
</html>